\DIFdelbegin %DIFDELCMD < \begin{DIFnomarkup}
%DIFDELCMD < \hypertarget{init}{}\section{Open and close
%DIFDELCMD < API}\label{init}
%DIFDELCMD < \end{DIFnomarkup}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \begin{DIFnomarkup}
\hypertarget{init}{}\section{Open and close
}\label{init}
\end{DIFnomarkup}
\DIFaddend

Since HSA core runtime is a user mode library, its state is a part
of the application's process space. When the runtime is opened for
the first time, a runtime instance for that application process is
created. Closing a runtime destroys this instance. An application
may open (or close) the HSA runtime multiple times within the same
process and potentially within multiple threads -- only a
single instance of the runtime, per-process, will exist.

The core runtime defines a runtime context that acts as a reference
counting mechanism and a scheme to differentiate multiple usages of
the runtime within the same application process. The runtime context
is generated when the runtime is opened or when a
user calls the acquire API that is defined in this Section. As an
example, consider an application that is using the runtime but also
uses a library, this library also creates HSA queues and submits
work to them. Both the library and the application may want to register
callbacks, and to capture notifications/errors of their specific
usage. The runtime context helps identify the different usages (within
the same process) and channel errors and notifications to
appropriate callbacks. It also acts as a reference counting
mechanism; while correctly \emphld{acquired}, the runtime context
ensures that the runtime instance will not be shutdown until the
context is \emphld{released} (this, in effect, is the reference
counting part of the context).

This section defines four new API, \ttbf{hsa\_open} to open the
runtime instance, \ttbf{hsa\_close} to close it,
\ttbf{hsa\_context\_acquire} to create a new context (and increment
the reference count), and, \ttbf{hsa\_context\_release} to release
the acquired context (and decrement the reference count).

Invocation of \ttbf{hsa\_open} initializes the HSA runtime if it is
not already initialized. It is allowed for applications to invoke
\ttbf{hsa\_open} multiple times and do multiple \ttbf{hsa\_close}
API calls. The HSA open call returns a new context at every
invocation.  Reference counting is a mechanism that allows the
runtime to keep a count of the number of different usages of the
runtime API within the same application process. This ensures that
the runtime stays active until a \ttbf{hsa\_close} is called by the
user when the reference count represented by that runtime context is
1.

The definition of the \ttbf{hsa\_open} API is as follows:

\input{example/APIhsa_initialize}

The open API returns \dbtt{HSA\_STATUS\_SUCCESS} if the
initialization was successful. Otherwise it returns one of the
following errors:

\begin{easylist}
& \dbtt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} if there is a
failure in allocation of an internal structure required by the core
runtime library. This error may also occur when the core runtime
library needs to spawn threads or create internal OS-specific
events.

& \dbtt{HSA\_STATUS\_ERROR\_COMPONENT\_INITIALIZATION} if there
is a non-specific failure in initializing one of the components.

& \dbtt{HSA\_STATUS\_ERROR\_CONTEXT\_NULL} if the context pointer
passed by the user is NULL. User is required to pass in a memory
backed context pointer.
\end{easylist}

If the HSA runtime is already initialized, an asynchronous
notification is generated by the runtime and
\dbtt{HSA\_STATUS\_SUCCESS} is returned. If the user chooses to
capture this asynchronous notification, the user should define a
callback and associate it with the context returned by the
\ttbf{hsa\_open} call.  Each \ttbf{hsa\_open} call increments the
reference count before returning success.

The runtime defines \ttbf{hsa\_close} as the corresponding API call
to finalize the use of the runtime API. This API takes in a context
as input. This API updates the reference count for every
invocation. Once the reference count is 0, it proceeds to relinquish
any resources allocated for the runtime and closes the runtime
instance. It is possible in a multi-threaded scenario that one
thread is doing a close while the other is trying to acquire the
runtime context or do an open. The core runtime specification
defines that an acquire with an input context that represents a
closed runtime instance will fail. However, \ttbf{hsa\_open} can be
called to create a new instance of the runtime after it is closed.
The API for \ttbf{hsa\_close} is defined as follows:

\input{example/APIhsa_close}

The close API returns \dbtt{HSA\_STATUS\_SUCCESS} if the close
was successful. Otherwise, it returns one of the following errors:

\begin{easylist}
& \dbtt{HSA\_STATUS\_ERROR\_NOT\_INITIALIZED} if the close was
called (a) either before the runtime was initialized, or (b)
after it has already been successfully closed.

& \dbtt{HSA\_STATUS\_ERROR\_RESOURCE\_FREE} if some of the
resources consumed during initialization by the runtime could not be
freed.
\end{easylist}

If the close is called when the reference count is not 1, it is
still considered a succesful invocation of close, in that, the
\dbtt{HSA\_STATUS\_SUCCESS} is returned with status
\dbtt{HSA\_STATUS\_CLOSE\_CONTEXT\_ACTIVE}, is generated by the
runtime on the context that is till active before the API returns.

The HSA core runtime API for an acquire on a context,
\ttbf{hsa\_context\_acquire}, is defined as follows:

\input{example/APIacquire_context}

The open API returns \dbtt{HSA\_STATUS\_SUCCESS} if the acquire was
successful and if {\itshape output\_context} holds the new context
generated. Otherwise it returns one of the following errors:

\begin{easylist}
& \dbtt{HSA\_STATUS\_ERROR\_NOT\_INITIALIZED} if the
\ttbf{hsa\_acquire\_context} was called (a) either before the
runtime was initialized, or (b) after it has already been
closed.
& \dbtt{HSA\_STATUS\_CONTEXT\_LIMIT\_REACHED} if the increment has
taken the context to the UINT64\_MAX value defined in
\texttt{stdint.h} C header file.
\end{easylist}

The corresponding release API, \ttbf{hsa\_context\_release} is
defined as follows:

\input{example/APIrelease_context}

The \ttbf{hsa\_context\_release} API returns
\dbtt{HSA\_STATUS\_SUCCESS} if the release was successful.
Otherwise it returns the following error:

\begin{easylist}
& \dbtt{HSA\_STATUS\_ERROR\_NOT\_INITIALIZED} if the
\ttbf{hsa\_release\_context} was called before the
runtime, after reference count has reached a value of 0.

Runtime context cannot be incremented beyond a 64bit unsigned
integer. The context does not wrap around.

\end{easylist}
\subsection{Open/Close Example}

\lstinputlisting{example/openclose.c}

