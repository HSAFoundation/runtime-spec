\hypertarget{finalizer}{}\section{Finalization, Compilation Unit,
Code, Debug and Symbol Objects}\label{finalizer}

Compilation support in the HSA core runtime comprises of a
finalization step. The primary functionality of this step is to
translate the HSAIL to a component specific instruction set and
produce a compilation unit. It resolves user defined symbols that
are not already bound via callbacks provided by the user.

HSA components may support HSAIL natively or may have a native ISA
that the HSAIL needs to be translated into. However, compilation is a
necessary step and is required despite a HSA components' native support
of HSAIL. This is because of two primary reasons:

\begin{enumerate}
\item  The HSA kernel code objects (accessible via the
\texttt{hsa\_compilationunit\_code\_t} structure, discussed in
Section~\ref{finalize:codeobject} ) are an output of the
finalization process and required as an input for the AQL dispatch
packet; to obtain values from the finalizer for segment sizes etc.\
and also to act as a container for component specific execution
information.

\item In order to support kernel dispatches from the HSA
component, the kernel code object must reside in a memory layout
specification since dispatches initiated from components are able
to use memory operations to get the information necessary for a
dispatch.
\end{enumerate}

Before discussing BRIG, etc., a constant \texttt{HSA\_CODE\_VERSION}
is defined by the runtime to represent the version of the code
object formats being used in this instance of the runtime.

\begin{lstlisting}
typedef uint32_t hsa_code_version32_t;
enum hsa_code_version_t {
  HSA_CODE_VERSION = 0
};
\end{lstlisting}

\subsection{BRIG and .directive Section}
The core runtime accepts H\-S\-A\-I\-L programs coded in the
B\-R\-I\-G binary format, as defined in the HSA PRM~\cite{prm}, for its
finalization process. BRIG is a binary format defined by the HSA
PRM and includes 5 different sections, \emph{.string},
\emph{.directive}, \emph{.code}, \emph{.operand}, and \emph{.debug}.
More information on these sections is described in Section 19.1 of
the HSA PRM. The core runtime structure that represents a
BRIG is named \texttt{hsa\_brig\_t}. This structure is an in-memory
representation of the BRIG. It is defined as follows:

\input{example/STRhsa_brig}

Of the different sections in BRIG, the .directive section provides
information to the finalizer on functions, kernels, and global
declarations, etc. The symbols in the .directive section have defined
placement rules (see PRM for more information). For example,
immediately after a function or kernel directive, BRIG requires the
directives that describe the arguments to be in a certain order.
Return arguments are first, followed by input arguments, followed by
the directives that apply only to the function or kernel.

The \texttt{hsa\_brig\_t} structure has the base address of the
directive section. A directive for any symbol is represented using
an offset into the directive section. HSA core runtime defines a
type \texttt{hsa\_brig\_directive\_offset\_t} to represent the
.directive section offset. It is typedef to an unsigned 32 bit
integer and is defined by all implementations as follows:

\begin{lstlisting}
typedef uint32_t hsa_brig_directive_offset_t;
\end{lstlisting}

There are different types of directives specified in the PRM. Of
these, the control directives are a means to allow implementations
to pass information to the finalizer via HSAIL. HSA runtime
defines a structure \texttt{hsa\_control\_directives\_t} to
represent the values of control directives both at finalization
time and to record information in the kernel code object. Control
directives may also be specified within the HSAIL code. When
conflicting values are specified for a particular directive
specified in HSAIL and at finalization time, the runtime will do one
of the following: (a) perform a union (OR operation) when possible
(e.g. when the value represents a bit field).

(b) when a union is not meaningful, the runtime will require that the value provided at
finalization time via the \texttt{hsa\_control\_directives\_t}
structure match the value for this directive in the HSAIL kernel.

The \texttt{hsa\_control\_directives\_t} structure is defined as
follows:

\input{example/STRcontrol_directive}

Where, the \texttt{hsa\_control\_directive\_present64\_t} is defined
as a 64bit unsigned integer.

\begin{lstlisting}
typedef uint64_t hsa_control_directive_present64_t;
\end{lstlisting}

The enumeration \texttt{hsa\_control\_directive\_present64\_t} is a
bit set indicating which control directives have been specified. It
is accessible via a mask,
\texttt{hsa\_control\_directives\_present\_mask\_t}, which
is defined as follows:

\input{example/ENUdirective_present}

User can choose to either break on exceptions or just detect them.
The PRM defines the policy to be exception-type specific, i.e.\ different
IEEE exceptions supported by HSA (see the definition of the
enumeration \texttt{hsa\_exception\_kind\_mask\_t} below)  can be
handled with different policies (BREAK vs.\ DETECT).
The {\itshape enable\_break\_exceptions} field specifies the set of
HSAIL exceptions that must have the BREAK policy enabled. It is
possible that on some systems, enabling exceptions may result in
lower code performance.
If the kernel being finalized has any \texttt{enablebreakexceptions}
control directives in HSAIL, then the runtime performs a union (OR
operation) of values specified by this argument with the values in
HSAIL control directives. If any of the functions the kernel calls
have an enablebreakexceptions control directive, then they must be
equal to or a subset of this union.

\input{example/ENUexception_type}

\subsection{Code Objects}\label{finalize:codeobject}

There are different code objects defined by the HSA core runtime
specification in support of HSAIL:
\texttt{hsa\_compilationunit\_code\_t},
\texttt{hsa\_kernel\_code\_t} and \texttt{hsa\_function\_code\_t}.
All of them are in memory and can be relocatable and/or position
independent (which indicates that the object can be deep-copied to
other memory locations for execution). The HSA runtime provides a
query API to verify if a particular component supports position
independent code objects (see Section~\ref{topology}).

The \texttt{hsa\_compilationunit\_code\_t} is the header for the
code object produced by the Finalizer and contains information that
applies to all code entities in the compilation unit.

Since core runtime does not define a file format container, the core
runtime provides API to work with HSAIL programs encoded in the BRIG
binary format and supports generation of code objects that
include kernels to be executed in the HSA component and binding
of unresolved symbols associated with the code object
generated.

Finalizer allocates a single contiguous area of memory to hold the
generated code for all the code objects.

The structure of this contiguous area is as follows: Starting at
offset 0, the ``header'' of this contiguous area is defined by the
\texttt{hsa\_compilationunit\_code\_t} structure. The
\texttt{hsa\_compilationunit\_code\_t} structure in turn contains
an offset to an array of \texttt{hsa\_code\_entry\_t}, one entry per
code entity that the finalizer has produced code for. Each
\texttt{hsa\_code\_entry\_t} variable contains an offset to a
\texttt{hsa\_*code\_t} object that describes that code entity
(function/kernel/etc).

The kinds of code objects that can be contained in a
\texttt{hsa\_compilationunit\_code\_t} is defined by the following
structure:
\input{example/ENUhsa_codekind}

The \texttt{hsa\_code\_entry\_t} structure is defined as follows:
\input{example/STRhsa_codeentry}

The current version number of the HSA code object
format is defined as follows:

\input{example/ENUhsa_codeversion}

Every \texttt{hsa\_*\_code\_t} code objects start with a common
header that also contains what kind of code object it is. The common
header, \texttt{hsa\_code\_t}, is defined as follows:
\input{example/STRhsa_codeheader}

A bit set of flags providing information about the code in a
compilation unit. Unused flags must be 0. The
\texttt{hsa\_code\_properties32\_t} must be used as a type for this
flag. The values/mask currently supported is defined as follows:
\input{example/ENUcodeproperties}

The \texttt{hsa\_compilationunit\_code\_t} structure is defined as
follows:
\input{example/STRhsa_compilationunit}

Both the \texttt{hsa\_compilationunit\_t} and
\texttt{hsa\_*\_code\_t} objects can have implementation define data
towards the end of the structure. All elements in the contiguous
location being accessed by offsets enables such definition.  This
also allows the exact position of the various objects in the
contiguous memory area to be implementation defined as long as
memory alignment requirements are met.

Many of the \texttt{hsa\_*\_code\_t} objects include a size field
which is required to be set to the size of the structure. This
allows forward compatibility and allows for structure definitions to
change or include implementation specific information.

The \texttt{hsa\_kernel\_code\_t} is required for all component
dispatches and is referred to by the dispatch AQL packets placed in
the HSA queue. This allows an implementation to rely on all such
objects being the same size for more efficient navigation to the
implementation specific data without need to first read the object's
size field.

The \texttt{hsa\_kernel\_code\_t} is the output of
\ttbf{hsa\_finalize\_brig} API and is defined as follows.

\input{example/STRcode_object}

\subsection{Finalize BRIG API}
The \ttbf{hsa\_finalize\_brig} API accepts \texttt{hsa\_brig\_t} as
an input and produces relocatable code object in which global and
group symbols are bound to actual, component recognizable,
addresses.  A symbol in the finalization step can be a variable, a
function, image or a sampler. When finalization occurs, a
\texttt{hsa\_kernel\_code\_t}, representing the kernel that needs to
be executed on the component is generated.  However, all the symbols
referenced in the kernel being finalized may not be resolved with
the information provided at its finalization. User is allowed to
define callbacks that can resolve the symbols declared in the global
segment.

The callback, \texttt{hsa\_map\_symbol\_address\_t}, is defined as
follows:
\begin{lstlisting}
typedef hsa_status_t (*hsa_map_symbol_address_t)(
  hsa_finalize_compilationunit_caller_t caller,
  hsa_brig_directive_offset_t symbol_directive,
  uint64_t* address);
\end{lstlisting}

The finalization step, when successfully executed, can have two
distinct outputs. The first is the compilation unit code object,
\texttt{hsa\_compilationunit\_code\_t} which is discussed in
Section~\ref{finalize:codeobject}. The second output is of type
\texttt{hsa\_compilationunit\_debug\_t} which is only generated when
the code is compiled with a debug option. This debug information is
currently implementation defined.

Since the contiguous memory that {\itshape
compilationunit\_code} represents and the memory for {\itshape
compilationunit\_debug} need to be allocated, the user is expected
to provide callbacks for memory allocation.

The callback is required to have the following signature:

\begin{lstlisting}
typedef hsa_status_t (*hsa_alloc_t)(
  hsa_finalize_brig_caller_t caller,
  size_t byte_size,
  size_t byte_alignment,
  void** address);
\end{lstlisting}

Where
caller is the opaque pointer passed to the
\ttbf{hsa\_finalize\_brig} that is calling back this function.
{\itshape byte\_size} is the size in bytes of the memory to be allocated.
{\itshape byte\_alignment} is the required byte alignment of the memory
allocated. Must be a power of 2.
{\itshape address} is pointer to location that will be updated with address of
allocated memory if successful, or NULL if not successful.
{\itshape return value} is the HSA status of the allocation.

The callback for the
allocation of {\itshape compilationunit\_debug} is optional and is
required when the user passes in a flag at finalization to generate
debug information. This callback, when defined, must have the same
signature as \texttt{hsa\_alloc\_t} above.

\input{example/APIfinalize_brig}

The \ttbf{hsa\_finalize\_brig} API returns
\texttt{HSA\_STATUS\_SUCCESS} when the finalization is successful.
Otherwise, it returns one of the following errors:

\begin{easylist}

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} If {\itshape brig}
is NULL or invalid, or if {\itshape kernel\_directive} is invalid.

& \texttt{HSA\_STATUS\_INFO\_UNRECOGNIZED\_OPTIONS} If the options
are not recognized, no error is returned, just an info status is
used to indicate invalid options.

& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} If the finalize API
cannot allocate memory for {\itshape compilationunit\_code/debug} or the
deserialize cannot allocate memory for {\itshape code\_object}.

& \texttt{HSA\_STATUS\_ERROR\_DIRECTIVE\_MISMATCH} If the directive
in the control directive structure and in the HSAIL kernel mismatch
or if the same directive is used with a different value in one of
the functions used by this kernel.
\end{easylist}

The \texttt{hsa\_code\_object\_t} is defined as follows:

\input{example/STRcontrol_directive}
\input{example/STRcode_object}

%\hypertarget{coreapi__finalizer_specifying_kernel}{}\subsection{Specifying
%Kernel Reference}\label{coreapi__finalizer_specifying_kernel}
The user must ensure that the B\-R\-I\-G is valid, failing which the
finalize API will return an error.  The desired kernel to finalize
is specified as a location in the B\-R\-I\-G. The location is
described as an offset into the B\-R\-I\-G .directive section.

H\-S\-A\-I\-L does not define a set of options that a finalizer
needs to specify. To ensure portability, \ttbf{hsa\_finalize\_brig}
must not return an error status if a given compilation option is not
recognized.

\subsection{Freeing The Compilation Unit Code/Debug Object}

The core runtime also provides a corresponding destruction API that
destroys the compilation unit code and debug objects.  This will
reclaim all memory used by the
\texttt{hsa\_compilationunit\_code\_t} (including the ISA it
contains) and associated \texttt{hsa\_compilationunit\_debug\_t}. It
will also unregister the ISA memory if appropriate.

\input{example/APIfinalize_destroy}

The \ttbf{hsa\_compilationunit\_code\_destroy} API destroys the
compilation unit code object where as
\ttbf{hsa\_compilationunit\_debug\_destroy} destroys the compilation
unit debug object.

Both API return \texttt{HSA\_STATUS\_SUCCESS} if the destruction was
successful. Otherwise, they can return one of the following errors:

\begin{easylist}

& \texttt{HSA\_STATUS\_ERROR\_RESOURCE\_FREE} if some of the
resources consumed during initialization by the runtime could not be
freed.

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
code\_object} or {\itshape debug\_object} is NULL or does not point
to a valid code object.

\end{easylist}

Note that destroying does not impact any memory segments that may
have been allocated/reserved for use in a kernel from this object.
It merely releases resources used to build the object.

\subsection{Serializing and Deserializing a Compilation Unit}

Because of the opaque nature of what the compilation unit actually
represents, and in order for the users of the core runtime to build
file containers, serialization and deserialization API are defined
by the core runtime. The definition is as follows:

\input{example/APIfinalize_serial}

\texttt{HSA\_STATUS\_SUCCESS} is returned if serialize/deserialize
API finish successfully. Success of serialize API means the
{\itshape code\_object} has been successfully serialized and then
copied into the location in memory ({\itshape serialized\_object}).
A successful deserialization recreates the code object, allocates
memory for it and returns it. One of the following errors may be
returned:
\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} If {\itshape
code\_object} or is NULL or does not point to a valid code object in
the serialize API. For the deserialize API, this means the {\itshape
serialized\_object} is either null or is not valid or the size is 0.

& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} If the serialize API
cannot allocate memory for {\itshape serialized\_object} or the
deserialize cannot allocate memory for {\itshape code\_object}.
\end{easylist}

%\subsection{Query Functions in Support of the}
%\texttt{hsa\_finalize\_brig} API

\hypertarget{coreapi_group_mem}{}\section{Group Memory
Usage}\label{coreapi_group_mem}
Group memory can be allocated either statically when the finalizer
is called or dynamically by the user at launch time.

Static allocation is supported as follows\-:

\begin{itemize}

\item The \ttbf{hsa\_finalize\_brig} routine writes the amount of
group memory needed by the finalized I\-S\-A to the
\texttt{hsa\_code\_object\_t}.{\itshape workgroup\_group\_segment\_size\_byte}
field.  The group memory usage includes group memory which is
statically allocated in the H\-S\-A\-I\-L kernel, as well as private
group memory used by the finalizer. Different H\-S\-A
implementations might allocate different amounts of group memory.

\item The user copies the requested group segment usage to the
A\-Q\-L dispatch packet's \texttt{hsa\_aql\_dispatch\_packet\_t}.{\itshape
group\_segment\_size\_bytes} field.

\item The packet processor reads the group memory usage field and
reserves the required resources at dispatch time.

\item Statically allocated group memory starts at a segment offset
of 0.

\end{itemize}

Dynamically allocated group memory allows the user to specify the
group memory size when the kernel is launched. This is useful to
support dynamic group memory allocation features supported by
languages such as Open\-C\-L. Essentially, the user manually
calculates the offset for each kernel argument (including the static
allocation in the calculation) and passes these as arguments to the
H\-S\-A\-I\-L kernel. Specifically\-:

\begin{itemize}

\item As above, the {hsa\_finalize\_brig} routine returns the
requested static group allocation.

\item H\-S\-A\-I\-L will use standard 32-\/bit arguments (that is,
\ttbf{kernarg\_u32}) to specify group segment offsets. The user is
responsible for computing the offset for each group memory argument
location. The first argument must start just above the static
allocation, so it always has the offset of
\texttt{hsa\_code\_object\_t}.{\itshape
workgroup\_group\_segment\_size\_byte}

\item After setting the offset for each group memory argument, the
user must set the \-Q\-L dispatch packet's
\texttt{hsa\_aql\_dispatch\_packet\_t}.{\itshape
group\_segment\_size\_bytes} field to the total amount of group
memory used (static and dynamic allocations).

\end{itemize}

See below for an example of setting up dynamic group memory
arguments for a kernel.
\begin{framed}
\lstinputlisting{example/group_sample.c}
\end{framed}

Here is the corresponding kernel and usage model\-:

\begin{framed}
\lstinputlisting{example/group_sample_hsail.c}
\end{framed}

