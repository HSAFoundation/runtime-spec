\hypertarget{coreapi_memory_registration}{}\section{Memory Registration and Deregistration}\label{coreapi_memory_registration}
\hypertarget{coreapi_registration_overview}{}\subsection{Overview}\label{coreapi_registration_overview}
One of the key features of H\-S\-A is its ability to share global
pointers between the host application and code executing on the
component. This ability means that an application can directly pass a
pointer to memory allocated on the host to a kernel function
dispatched to a component without an intermediate copy, as illustrated
by the example shown in \hyperlink{coreapi}{Core A\-P\-I
Documentation}.

When a buffer will be accessed by a kernel running on a H\-S\-A
device, programmers are encouraged to register the corresponding
address range beforehand by using the appropriate H\-S\-A core
A\-P\-I invocation. While kernels running on H\-S\-A devices can
access any valid system memory pointer allocated by means of
standard libraries (for example, malloc in the C language) without
resorting to registration, there might be a performance benefit from
registering the buffer with the H\-S\-A core component. When an
H\-S\-A program no longer needs to access a registered buffer in a
device, the user should deregister that virtual address range by
using the appropriate H\-S\-A core A\-P\-I invocation.

The API for registering and deregistering is defined as follows:

\input{example/APIregister}.

This API returns \texttt{HSA\_STATUS\_SUCCESS} to indicate that
registration/deregistration has been successfully performed.
Otherwise, it returns one of the following for status:

\begin{easylist}

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if a NULL value is
passed for {\itshape address} or 0 for size.

& \texttt{HSA\_STATUS\_INFO\_NOT\_REGISTERED} this is applicable to
\ttbf{hsa\_memory\_deregister} API and indicates that a deregistration
is attempted on an address of memory that has not been registered or
a part of prior registered ranges.

& \texttt{HSA\_STATUS\_INFO\_OUT\_OF\_RESOURCES} if there is a
failure in allocating necessary resources to perform registration.
Note that this is just info, since registration doesn't impact
functionality, the user can still continue considering this an info.

\end{easylist}

\hypertarget{coreapi_registration_usage}{}\subsection{Usage}\label{coreapi_registration_usage}

A buffer is registered by indicating its starting address and a
size. The size does not need to match that of the original
allocation. For example\-:

\begin{framed}
\begin{lstlisting}
void* ptr = malloc(16);
status = hsa_memory_register(ptr, 8);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

 is a valid program. On the other hand\-:

\begin{framed}
\begin{lstlisting}
void* ptr = malloc(16);
status = hsa_memory_register(ptr, 20);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

is not a valid program, because we are registering a range that
spans several allocations, or might not be entirely allocated.

Registrations can overlap previously registered intervals. A special
case of overlapped registrations is multiple registration. If the
same interval is registered several times with different sizes, the
H\-S\-A core component will select the maximum as the size of all
the registrations. Therefore, the following program\-:


\begin{framed}
\begin{lstlisting}
status = hsa_memory_register(ptr, 8);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
status = hsa_memory_register(ptr, 16);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

behaves identically to this program\-:

\begin{framed}
\begin{lstlisting}
hsa_memory_register(ptr, 16);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
hsa_memory_register(ptr, 16);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

While the described behavior might seem counterintuitive, consider
the following scenario\-: A pointer is registered twice with
different sizes s1 and s2. When the pointer is deregistered, which
interval should be deregistered\-: (p, s1) or (p, s2)? If all the
registrations of the same pointer are considered identical by the
core runtime, that problem is eliminated.

Deregistering a pointer that has not been previously registered
results in an \emph{info} status indicating the same.

The following code snippet revisits the introductory example. The
code is almost identical to the original, except that we register
the buffers that will be accessed from the device after allocating
them, and we deregister all that memory before releasing it. In some
platforms, we expect this version to perform better than the
original one.

\hypertarget{coreapi_device_memory}{}\section{Core Memory Allocation
and Copy API}\label{coreapi_device_memory}

While a HSA component is capable of accessing pageable system memory
by definition, for scenarios where wants memory allocated that has
already been registered (combine the allocation with memory
registration described in
Section~\ref{coreapi_registration_overview}), the HSA runtime
provides an interface, \texttt{hsa\_memory\_allocate} to allocate
memory that is internally registered by the runtime.

Note that since registration is a performance hint, allocating
memory through this API corresponds to the \emph{hint}. The API is
defined as follows:

\input{example/APImemory_allocate}

If the memory is allocated successfully, the API returns
\texttt{HSA\_STATUS\_SUCCESS}. Otherwise, it returns one of the
folling error status values:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} if there is a
failure in allocation. This error may also occur when the core
runtime library needs to spawn threads or create internal
OS-specific events.

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
address} or {\itshape size} are not valid Allocation of size 0 is
allowed and returns a NULL pointer.
\end{easylist}

\hypertarget{coreapi_kernarg}{}\subsection{Allocation of Kernarg
Memory}\label{kernargmem}

The kernarg memory that AQL packet points to (see Section~\ref{AQL})
holds information about any arguments required to execute AQL
dispatch on a HSA component. While any system memory may be used for
kernarg memory, implementation/platform specific optimizations are
possible if HSA core runtime provided API are utilized for
allocating and copying to the allocated kernarg memory. To
facilitate such optimizations, HSA core runtime defines the
following API:

\input{example/APIkernargmem}

If the memory is allocated/copied successfully, the API returns
\texttt{HSA\_STATUS\_SUCCESS}. Otherwise, one of the
folling error status values are returned:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} if there is a
failure in allocation. This error may also occur when the core
runtime library needs to spawn threads or create internal
OS-specific events.

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
address} or {\itshape size} are not valid. Allocation of size 0 is
allowed and returns a NULL pointer.

@ \texttt{HSA\_STATUS\_ERROR\_COPY\_SOURCE\_INVALID} if the source
of the copy operation is invalid.

@ \texttt{HSA\_STATUS\_ERROR\_COPY\_DESTINATION\_INVALID} if the
destination of the copy operation is invalid. If both source and
destination are invalid, only destination error is reported.
\end{easylist}

\hypertarget{coreapi_device_memory}{}\subsection{Component Local Memory}\label{coreapi_device_memory}

Component local memory is a memory type that is dedicated
specifically for a particular HSA component. This memory could
provide higher bandwidth for component access (than system memory)
with the limitation that the host might not be able to access it
directly.

H\-S\-A runtime provides host interface to allocate/deallocate and
access component local memory. The result of the allocation is a
pointer to an address in application processes address space, which
can be accessed directly by the component during kernel execution.

The API is defined as follows:

\input{example/APImemory_local}

All three API return \texttt{HSA\_STATUS\_SUCCESS} when the
allocate/free/copy is successful. Otherwise, one of the following
status values is returned:

\begin{easylist}

& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} if there is a
failure in allocation of an internal structure required by the core
runtime library. This error may also occur when the core runtime
library needs to spawn threads or create internal OS-specific
events. The \ttbf{hsa\_memory\_allocate\_component\_local} and
\ttbf{hsa\_memory\_copy\_component\_local\_to\_system} API can
return this error.

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
component}, {\itshape address}, {\itshape src} or {\itshape dst} are
not valid and if the {\itshape address} pointer in
\ttbf{hsa\_memory\_allocate\_component\_local} is NULL. Allocation
of size 0 is allowed.

\end{easylist}

\hypertarget{coreapi_device_memory_usage}{}\subsection{Usage}\label{coreapi_device_memory_usage}

Component memory is allocated by indicating the size and the H\-S\-A
device it corresponds to. For example, the following code allocates
1024 bytes of device local memory\-:

\begin{framed}
\begin{lstlisting}
void* component_ptr = NULL;
hsa_memory_allocate_component_local(1024, component, &component_ptr);
\end{lstlisting}
\end{framed}

To access component memory from the host, the user can call
\ttbf{hsa\_memory\_copy\_component\_local\_to\_host} in similar
fashion as in memcpy. This interface allows the user to
perform component-\/to-\/host memory copy. For example\-:

\begin{framed}
\begin{lstlisting}
 const size_t DATA_SIZE = 1024;
 void* src_ptr = malloc(DATA_SIZE);
 void* dest_ptr = NULL;
 hsa_memory_allocate_component_local(DATA_SIZE, device, &dest_ptr);
 hsa_memory_copy_component_local_to_system(dest_ptr, src_ptr, DATA_SIZE);
\end{lstlisting}
\end{framed}

copies 1024 bytes from system to component local memory.

The user should not register or deregister component local memory.

