\hypertarget{coreapi_memory_registration}{}\section{Memory Registration and Deregistration}\label{coreapi_memory_registration}
\hypertarget{coreapi_registration_overview}{}\subsection{Overview}\label{coreapi_registration_overview}
One of the key features of H\-S\-A is its ability to share global
pointers between the host application and code executing on the
device. This ability means that an application can directly pass a
pointer to memory allocated on the host to a kernel function
dispatched to a device without an intermediate copy, as illustrated
by the example shown in \hyperlink{coreapi}{Core A\-P\-I
Documentation}.

When a buffer will be accessed by a kernel running on a H\-S\-A
device, programmers are encouraged to register the corresponding
address range beforehand by using the appropriate H\-S\-A core
A\-P\-I invocation. While kernels running on H\-S\-A devices can
access any valid system memory pointer allocated by means of
standard libraries (for example, malloc in the C language) without
resorting to registration, there might be a performance benefit from
registering the buffer with the H\-S\-A core component. When an
H\-S\-A program no longer needs to access a registered buffer in a
device, the user should deregister that virtual address range by
using the appropriate H\-S\-A core A\-P\-I invocation.

The API for registering and deregistering is defined as follows:

\input{APIregister}.

This API returns \texttt{HSA\_STATUS\_SUCCESS} to indicate that
registration/deregistration has been successfully performed.
Otherwise, it returns one of the following for status:

\begin{easylist}

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if a NULL value is
passed for {\itshape address} or 0 for size.

& \texttt{HSA\_STATUS\_INFO\_NOT\_REGISTERED} this is applicable to
\ttbf{hsa\_memory\_deregister} API and indicates that a deregistration
is attempted on an address of memory that has not been registered or
a part of prior registered ranges.

& \texttt{HSA\_STATUS\_INFO\_OUT\_OF\_RESOURCES} if there is a
failure in allocating necessary resources to perform registration.
Note that this is just info, since registration doesn't impact
functionality, the user can still continue considering this an info. 

& \texttt{status \textgreater \, HSA\_STATUS\_OTHER\_BEGIN} Any
implementation specific error has a error value \textgreater
\texttt{HSA\_STATUS\_OTHER\_BEGIN} (see~\ref{error} for details).
One cause for this status could be that registration is not
supported on a particular platform.

\end{easylist}

\hypertarget{coreapi_registration_usage}{}\subsection{Usage}\label{coreapi_registration_usage}

A buffer is registered by indicating its starting address and a
size. The size does not need to match that of the original
allocation. For example\-:

\begin{framed}
\begin{lstlisting}
void* ptr = malloc(16);
status = hsa_memory_register(ptr, 8);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT) 
  handle_error(status);
\end{lstlisting}
\end{framed}

 is a valid program. On the other hand\-: 

\begin{framed}
\begin{lstlisting}
void* ptr = malloc(16);
status = hsa_memory_register(ptr, 20);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

is not a valid program, because we are registering a range that
spans several allocations, or might not be entirely allocated.

Registrations can overlap previously registered intervals. A special
case of overlapped registrations is multiple registration. If the
same interval is registered several times with different sizes, the
H\-S\-A core component will select the maximum as the size of all
the registrations. Therefore, the following program\-:


\begin{framed}
\begin{lstlisting}
status = hsa_memory_register(ptr, 8);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
status = hsa_memory_register(ptr, 16);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

behaves identically to this program\-:

\begin{framed}
\begin{lstlisting}
hsa_memory_register(ptr, 16);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
hsa_memory_register(ptr, 16);
if(status == HSA_STATUS_ERROR_INVALID_ARGUMENT)
  handle_error(status);
\end{lstlisting}
\end{framed}

While the described behavior might seem counterintuitive, consider
the following scenario\-: A pointer is registered twice with
different sizes s1 and s2. When the pointer is deregistered, which
interval should be deregistered\-: (p, s1) or (p, s2)? If all the
registrations of the same pointer are considered identical by the
core runtime, that problem is eliminated.

Deregistering a pointer that has not been previously registered
results in an \emph{info} status indicating the same.

The following code snippet revisits the introductory example. The
code is almost identical to the original, except that we register
the buffers that will be accessed from the device after allocating
them, and we deregister all that memory before releasing it. In some
platforms, we expect this version to perform better than the
original one.

\hypertarget{coreapi_device_memory}{}\section{Core Memory Allocation
and Copy API}\label{coreapi_device_memory}

\hypertarget{coreapi_kernarg}{}\subsection{Allocation of Kernarg and
Read-Only Memory}\label{kernargmem}


\hypertarget{coreapi_device_memory}{}\subsection{Component Local Memory}\label{coreapi_device_memory}

Component local memory is a memory type that is dedicated
specifically for a particular HSA component. This memory could
provide higher bandwidth for component access (than system memory)
with the limitation that the host might not be able to access it
directly.

H\-S\-A provides host interface to allocate/deallocate and access
component local memory. The result of the allocation is a pointer to an
address in application processes address space, which can be
accessed directly by the component during kernel execution.

The API is defined as follows:

\input{APImemory_local}

All three API return \texttt{HSA\_STATUS\_SUCCESS} when the
allocate/free/copy is successful. Otherwise, one of the following
status values is returned:

\begin{easylist}

& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} if there is a
failure in allocation of an internal structure required by the core
runtime library. This error may also occur when the core runtime
library needs to spawn threads or create internal OS-specific
events. The \ttbf{hsa\_memory\_allocate\_component\_local} and
\ttbf{hsa\_memory\_copy\_component\_local\_to\_system} API can
return this error. 

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
component}, {\itshape address}, {\itshape src} or {\itshape dst} are
not valid and if the {\itshape address} pointer in
\ttbf{hsa\_memory\_allocate\_component\_local} is NULL. Allocation
of size 0 is allowed. 

\end{easylist}

\hypertarget{coreapi_device_memory_usage}{}\subsection{Usage}\label{coreapi_device_memory_usage}

Component memory is allocated by indicating the size and the H\-S\-A
device it corresponds to. For example, the following code allocates
1024 bytes of device local memory\-:

\begin{framed}
\begin{lstlisting}
void* component_ptr = NULL;
hsa_memory_allocate_component_local(1024, component, &component_ptr);
\end{lstlisting}
\end{framed}

To access component memory from the host, the user can call
\ttbf{hsa\_memory\_copy\_component\_local\_to\_host} in similar
fashion as in memcpy. This interface allows the user to
perform component-\/to-\/host memory copy. For example\-:

\begin{framed}
\begin{lstlisting}
 const size_t DATA_SIZE = 1024;
 void* src_ptr = malloc(DATA_SIZE);
 void* dest_ptr = NULL;
 hsa_memory_allocate_component_local(DATA_SIZE, device, &dest_ptr);
 hsa_memory_copy_component_local_to_system(dest_ptr, src_ptr, DATA_SIZE);
\end{lstlisting}
\end{framed}

copies 1024 bytes from system to component local memory.

The user should not register or deregister component local memory. 

