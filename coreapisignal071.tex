\hypertarget{signals}{}\section{Memory based Signals and
Synchronization in H\-S\-A}\label{signals}

In a HSA system, memory is coherent and can serve as a means for
message passing, asynchronous communication or synchronization
between various elements.  A signal is an alternative, possibly more
power-efficient, communication mechanism between two entities in a
H\-S\-A system. A signal carries a value, which can be updated or
conditionally waited upon via an API call or an HSAIL
instruction~\cite{prm}. A signal structure is opaque and is
always typedef'ed to \dbtt{uint64\_t}. 
Implementations can use the most power-efficient send-propagation
and wait techniques available to them on the HSA system.  
%Implementations may chose to
%make it a pointer to a private, internal, signal structure.

The HSA SAR Specification \cite{sar} identifies HSA Agent as a
participant in a HSA memory based signaling and synchronization.
This feature, as stated in the HSA SAR Specification, requires a
runtime API for allocation of signals that may be used for
synchronization and states that the signal is opaque and may contain
implementation specific information.  

An API, \ttbf{hsa\_signal\_create}, to support
creation of signals, is defined as follows:

\input{APIsignal_create}

The signal create API returns \texttt{HSA\_STATUS\_SUCCESS} if the
signal object has been successfully created. Otherwise, it returns
one of the following:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_OUT\_OF\_RESOURCES} if there is a failure
in allocation of an internal structure required by the core runtime
library in the context of the message queue creation. This error may
also occur when the core runtime library needs to spawn threads or
create internal OS-specific events. 
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
\diffblock{signal\_handle}} is NULL or an invalid pointer of it an invalid/NULL
context is passed in as an argument.
\end{easylist}

Once a signal is created for a particular context, it may be bound
to other contexts. This is useful when signal is used across
different components of a users application. An API to bind the
signal to a particular runtime context is defined as follows:

\input{APIsignal_bind}

This API returns \texttt{HSA\_STATUS\_SUCCESS} if the bind was
successful. Otherwise, it returns one of the following errors:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} is {\itshape
signal\_handle} is NULL or invalid or if the {\itshape context} is
NULL or invalid. 
\end{easylist}

The corresponding signal destruction API is defined as follows:

\input{APIsignal_destroy}
The signal destroy API returns \texttt{HSA\_STATUS\_SUCCESS} if the
signal object has been successfully destroyed. Otherwise, it returns
one of the following:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
signal\_handle} is invalid.
\end{easylist}

A signal can also be unbound from a particular context if the user
no longer wants to receive notifications about this signal in the
callback registered for that context. The API to unbind is defined
as follows:

\input{APIsignal_unbind}

The API returns \texttt{HSA\_STATUS\_SUCCESS} if the signal is
successfully unbound from the context. Otherwise, it can return one
of the following errors:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_SIGNAL\_NOT\_BOUND} if the signal was
not already bound to that context.

& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} is {\itshape
signal\_handle} is NULL or invalid or if the {\itshape context} is
NULL or invalid. 
\end{easylist}

As per the HSA SAR specification the signals may only be created and
operated on by either instructions in HSAIL or the HSA runtime API.
Sending a signal entails updating a particular value at the signal.
Waiting on a signal returns the current value at the opaque signal
object -- the wait has a runtime defined timeout which indicates the
maximum amount of time that an implementation can spend waiting for
a particular value before returning. 

The API to query the timeout is defined as:

\input{APIsignal_timeout}

This getter API does not return a status.  This API returns the
timeout, which indicates the maximum amount of time an
implementation can spend in a wait operation on the signal. The
return value is in the units of 
the system-wide clock who's frequency is available via the
\dbtt{hsa\_platform\_t} structure (see Section~\ref{topology}). As
per SAR, the HSA system has a system-wide timestamp that operates at
a fixed frequency. The frequency can be
queried via the \texttt{hsa\_platform\_t} structure defined in
Section~\ref{topology}. The timeout is incremented at the same
frequency.  The user can use this information to translate the
timeout to a different frequency domain. 

The send signal API sets the signal handle with caller specified
value. Any subsequent wait on the signal handle would be given 
a copy of this new signal value after the wait condition 
is met (and before the timeout expires).  The signal infrastructure
allows for multiple waiters on a single signal. A multi-threaded
user application can have multiple threads sending and waiting on
signals. 

In addition to the update of signals using
Send, the API for send signal must support other atomic operations as
well. HSA defines \emph {AND, OR, XOR, Exchange, Add, Subtract,
Increment, Decrement, Maximum, Minimum} and \emph{CAS}. Apart from
the no synchronization case, which is referred to as \emph{none}
synchronization, there are three types of synchronization defined in
the systems architecture requirements: 

\begin{description}
        \item[Acquire synchronization] \hfill \\ 
                No memory operation listed after the acquire can be
                executed before the acquire-synchronized operation. Acquire
                synchronization can be applied to various operations
                including a load operation.
        \item[Release synchronization] \hfill \\ 
                No memory operation listed before the release can be
                executed after the release-synchronized operation. Release
                synchronization can be applied to various operations
                including a store operation.
        \item[Acquire-Release synchronization] \hfill \\
                This acts like a fence. No memory operation listed
                before the Acquire-Release synchronized operation
                can be move after it nor can any memory operation
                listed after the Acquire-Release synchronized
                operation can be executed before it.
        \item[Relaxed synchronization] \hfill \\
                No synchronization is applied to the send or wait
                operation.
\end{description}
                
Each operation on a signal value has the type of synchronization
explicitly included in its name. For example, Send-Release is a Send
on a signal value with Release synchronization.

Hence, the following represent the complete set of actions (with
associated synchronization) that can be performed on a signal value:
Send with release, 
Send with relaxed,
AND with release,
AND with relaxed,
OR with release,
OR with relaxed,
XOR with release,
XOR with relaxed,
Exchange with acquire-release,
Exchange with relaxed,
Add with release,
Add with relaxed,
Subtract with release,
Subtract with relaxed,
Increment with release,
Increment with relaxed,
Decrement with release,
Decrement with relaxed,
Maximum with acquire-release,
Maximul with relaxed,
Minimum with acquire-release,
Minimum with relaxed,
CAS release.

For efficiency, a unique signal API has been created for each of
these actions. In the description of the API, for convenience, 
\emph{value@signal\_handle} is used to represent the value at a
signal. 

\input{APIsignal_all}

All of the \ttbf{signal\_send} API return
\texttt{HSA\_STATUS\_SUCCESS} if the send is successful, any atomic
operation that needed to be performed has been done successfully and
any result value that needs to be returned has been copied into the
user-given location. One of the following error values may be
returned in case the send is not successful:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if (a) the user is
expecting an output but the pointer to the output signal value is
invalid, (b) the {\itshape signal\_value} doesn't represent a valid
signal.
\end{easylist}

The user may wait on a signal, with a condition specifying the terms
of wait. The wait can be done either in the HSA Component via.\ an
HSAIL wait instruction or via.\ a runtime API defined here. 
Waiting on a signal returns the current value at the signal. The
wait may return before the condition is satisfied or even before a
valid value is obtained from the signal. It is the users burden to
check the return status of the wait API before consuming the
returned value. 

Wait \emph{reads} the value, hence Acquire and Acquire-Release
synchronizations may be applied to the read. The synchronization
should only assumed to have been applied if the status returned by
the wait API indicates a success (i.e. return type is
\texttt{HSA\_STATUS\_SUCCESS}). The two wait APIs to support both the
synchronizations are defined as follows:

\input{APIsignal_wait}

The user must always check the return value of the wait before
considering the {\itshape wait\_value} as the wait may have returned
due to a timeout. The wait API can return the following status:
\begin{easylist}
& If an error is signaled on the signal the user is waiting on, the
wait API returns \texttt{HSA\_STATUS\_ERROR} to indicate that an
error has occurred. The API still returns the current value at the
signal. The user may also inspect the value returned.
when an error occurred (see Section~\ref{signal_error}).
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if (a) the user is
expecting an output but the pointer to the output signal value is
invalid, (b) the {\itshape signal\_value} doesn't represent a valid
signal.
& \texttt{HSA\_STATUS\_INFO\_SIGNAL\_TIMEOUT} the signal wait has
timedout.
\end{easylist}

The \texttt{hsa\_wait\_condition\_t} is defined as follows:

\input{ENUwait_condition}

The runtime also defines an API to query the current signal value.
If the signal is being updated by the component or other threads,
there is no guarantee that the value returned by the query API is
the value of the signal even at the instance it has been returned.
Queried value may be used to check progress of a kernel, if the
kernel were updating the signal at various stages of its execution.
Query is a non-blocking API and does not take
\texttt{hsa\_wait\_condition\_t} as input. It merely obtains the
current value at the signal.

The \texttt{hsa\_signal\_query\_acquire} API is defined as follows:

\input{APIsignal_query} 

The \texttt{hsa\_signal\_query\_acquire} API returns
\texttt{HSA\_STATUS\_SUCCESS} when the value at the signal has been
successfully returned. Otherwise, it returns one of the following
errors:

\begin{easylist}
& \texttt{HSA\_STATUS\_ERROR\_INVALID\_ARGUMENT} if {\itshape
signal\_handle} is invalid.
\end{easylist}

Signals may be utilized in many ways. For example, a running kernel,
after it finishes producing a part of its computation, may set the
signal in the dependency packet of another kernel dispatch so that
the queue processor can resolve the dependency and launch the kernel.

Signals cannot be used for Inter-Process Communication (IPC).

\hypertarget{signal_error}{} \subsection{ Indicating Errors with
Signals} \label{signal_error}
To put the signal in error state, the two most significant bits in
the signal value are set and all other bits cleared. It is the users
burden to check to see if an error has occurred by looking at the
return code of the
\texttt{hsa\_signal\_wait<acquire\_release/Acquire>} API. Any
negative value at the signal triggers the
\texttt{HSA\_STATUS\_ERROR} return code from the wait API. A signal
that is already in error may further be decremented to a larger
negative value. 

\hypertarget{signal_example}{} \subsection{Usage Example}
\label{signal_example}
